#!/bin/bash
# vim: sw=2:ts=2:sts=2

# abb is command-line client for abf <http://abf.rosalinux.ru>
# Copyright (C) 2012 alexander barakin aka sash-kan <alex@barak.in>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# defaults:

# using proto (http|https)
proto=https
# server
server=abf.rosalinux.ru
# yes yes!
export GIT_SSL_NO_VERIFY=true
# owner of repo (user name or group name)
owner=import
# default branch
branch=rosa2012.1
# default remote
remote=origin
# insecure:
#auth=user:password
# more secure, but very-very uncomfortable:
#auth=user
# default rpmbuild action
action="-bb"
# name of abf yml file to store sha1sums
abfyml=".abf.yml"
# write buildlog (any, even empty value, cancels log creation)
buildlog=yes
# do restore after clone (always,ask,none)
restore=always
# limit rows of "status" output
rows=4
# interval (seconds) to refresh "status" output
refresh=120
# path to spec skeleton
defaultspec=/usr/share/abb/spek.skel

# get user settings
# first look in ~/.abbrc
[ -f ~/.abbrc ] && . ~/.abbrc
# if it does not exist then look for .abbrc in curdir
[ ! -f ~/.abbrc -a -f .abbrc ] && . .abbrc
# if both do not exist, using defaults written above

usage() {
	[ $# == 1 ] && echo -e "$1"
  cat <<EOT
usage:
$0 clone <name of project>
$0 build [<name of project>]
$0 restore [<name of project>]
$0 store <name of file>

settings are in ~/.abbrc
see readme, please!
EOT
	exit 1
}

yesno() {
	local cont
	read -p "$@ is it ok? (Y|n): " cont
	[ "${cont}" == "" -o "${cont}" == "y" -o "${cont}" == "Y" ] && return 0
	return 1
}

get_project_from_curdir() {
	# believe that we are in a directory with the source
	#project=$(basename $PWD)
	# more smart method
	# 1. try git
	project=$(git config remote.origin.url | sed -rn '/.*'${owner}'\/[^\/]*$/{s/\.git$//;s!^.*/!!;p}')
	if [ -n "${project}" ]; then
		[ "${silent}" == "1" ] || echo "assume project name from git url: ${project}"
	elif [ $(ls *.spec 2>/dev/null | wc -l) -eq 1 ]; then
		# 2. try spec name
		project=$(basename $(ls *.spec) .spec)
		[ "${silent}" == "1" ] || echo "assume project name from spec-file name: ${project}"
	elif [ $# -eq 1 -a "$1" == "nodir" ]; then
		:
	else
		# 3. assume that project == current dir
		project=$(basename $PWD)
		[ "${silent}" == "1" ] || echo "assume project name from name of curdir: ${project}"
	fi
}

do_restore() {
	if [ ${in_proj_dir} -eq 0 ]; then
		pushd "$project" >/dev/null || return 1
	fi
	local file sha
	echo "try to restore files from abf storage"
	if [ "${abfyml}" == "" ]; then
		echo "error: name of abf yml file not specified"
		echo "for example:"
		echo "$0 $command abfyml=.abf.yml"
	else
		if [ -e "${abfyml}" ]; then
			echo "parsing file '${abfyml}'"
			sed -rn '$G;s/^[\"'\''[:space:]]*([^[:space:]:\"'\'']+)[\"'\''[:space:]]*.*[\"'\''[:space:]]*([0-9a-fA-F]{40})[\"'\''[:space:]]*$/\1 \2/p' ${abfyml} | \
			while read file sha; do
				#echo -n "found entry: file=${file} sha1sum=${sha} ... "
				echo -n "found entry: file=${file} ... "
				if [ -e ${file} ]; then
					if echo "${sha}  ${file}" | sha1sum -c --status; then
						echo "ok"
					else
						echo "sha1sum INCORRECT! skipping..."
					fi
				else
					echo -n "try to download... "
					if wget -qO - "http://file-store.rosalinux.ru/download/${sha}" > "${file}"; then
						echo "ok"
						echo -n "check sum... "
						if echo "${sha}  ${file}" | sha1sum -c --status; then
							echo "ok"
						else
							echo "sha1sum INCORRECT! skipping..."
						fi
					else
						echo "filed! skipping..."
					fi
				fi
			done
		fi
	fi
	if [ ${in_proj_dir} -eq 0 ]; then
		popd >/dev/null
	fi
}

do_clone() {
	url="${projurl}/${project}.git"
	git clone "$url" || return 1
	[ -d "$project" ] || return 1
	pushd "$project" >/dev/null
	if [ -n "$branch" ]; then
		echo "try to checkout to branch '$branch' of remote '$remote'" 
		git checkout -t "$remote/$branch"
	fi
	if [ "${restore}" == "always" ]; then
		in_proj_dir=1 do_restore
	elif [ "${restore}" == "ask" ] && yesno "restore files."; then
		in_proj_dir=1 do_restore
	fi
	popd >/dev/null
}

do_build() {
	if [ ${in_proj_dir} -eq 0 ]; then
		pushd "$project" >/dev/null || return 1
	fi
	if [ "${restore}" == "always" ]; then
		in_proj_dir=1 do_restore
	elif [ "${restore}" == "ask" ] && yesno "restore files."; then
		in_proj_dir=1 do_restore
	fi
	echo "try to build ${project}"
	local d=$PWD
	local spec=(*.spec)
	if [ ${#spec[@]} -eq 1 ]; then
		local cmd="mkdir -p ${d}/BUILD; rpmbuild --define '_topdir ${d}' --define '_sourcedir ${d}' ${spec}"
		if [ "${buildlog}" == "yes" ]; then
			local logname="${project}.${action}.$(/bin/date +%Y%m%d-%H%M%S.$(printf %05d $$)).$(hostname -s).buildlog"
			eval $cmd $action "${opts[@]}" 2>&1 | tee ${logname}
			echo "build log is saved in ${logname}"
		else
			eval $cmd $action "${opts[@]}"
		fi
	else
		echo "one and only one spec required in current dir"
	fi
	if [ ${in_proj_dir} -eq 0 ]; then
		popd >/dev/null
	fi
}

do_store() {
	local file=${project}
	if [ "${abfyml}" == "" ]; then
		echo "error: name of abf yml file not specified"
		echo "for example:"
		echo "$0 $command $file abfyml=.abf.yml"
		return 1
	fi

	local sha=$(sha1sum "${file}" | sed 's/\s.*//')
	echo "sha1sum = '${sha}'"

	if [ -e "${abfyml}" ]; then
		if grep -qE "\<${file}\>|\<${sha}\>" ${abfyml}; then
			echo "file '${abfyml}' also contains this line:"
			grep -E "\<${file}\>|\<${sha}\>" ${abfyml}
			echo "aborting..."
			return 1
		fi
	fi

	echo -n "check if file also stored... "
	if wget -q --spider http://file-store.rosalinux.ru/download/${sha}; then
		echo "yes"
		echo "skip storing"
	else
		echo "no"
		echo "try to store file ${file}"
		local curloutput=$(curl -s -X POST -F "file_store[file]=@${file}" http://${auth}file-store.rosalinux.ru/api/v1/upload)

		echo -n "check if file stored correctly... "
		if wget -q --spider http://file-store.rosalinux.ru/download/${sha}; then
			echo "ok"
		else
			echo "error: can't check"
			echo "curl output:"
			echo ${curloutput}
			echo "aborting..."
			return 1
		fi
	fi
	if [ ! -e "${abfyml}" ]; then
		echo "${abfyml} not exist, create one"
		#echo "---" > "${abfyml}"
		echo "sources:" >> "${abfyml}"
	fi
	echo "adding line to '${abfyml}'"
	# fix missing newline at end of .abf.yml
	sed -i '$a\' "${abfyml}"
	echo "  ${file}: ${sha}" >> "${abfyml}"
}

do_status() {
	local out="" out2="" sleep_cmd="break"
	if [ -n "${refresh}" ] && [ ${refresh} -ge 60 ] 2>/dev/null; then
		sleep_cmd="sleep ${refresh}; date"
		echo "query server every ${refresh} seconds (see readme)"
	fi
	echo "Id Status Project Version SaveToRepository Architecture User"
	while true; do
		#out2=$(lynx -dump "https://${auth}abf.rosalinux.ru/${owner}/${project}/build_lists" | \
		out2=$(lynx -dump "${projurl}/${project}/build_lists" | \
			sed -rn '/^[[:space:]]+\[[0-9]+\][0-9]+ /{N;N;s/\[[0-9]+\]//g;s/\n/ /g;s/ +/ /g;p}' | \
			tac | tail -n ${rows})
		comm --nocheck-order -1 -3 <(echo "${out}") <(echo "${out2}")
		out="$out2"
		eval ${sleep_cmd}
	done
}

substvars() {
	cat "$1" | sed -r 's/@@project@@/'${project}'/g' > $2
	# another case, imho dangerous
	#eval "echo \"$(< $1)\"" > $2
}

do_new() {
	url="${projurl}/${project}.git"
	[ -d ${project} ] && { echo "directory '${project}' exists, not creating new project"; return 1; }
	mkdir ${project}
	pushd ${project} >/dev/null
	if [ -r "${defaultspec}" ]; then
		substvars "${defaultspec}" ${project}.spec
	else
		echo "can't read '${defaultspec}', not creating ${project}.spec"
	fi
	git init
	echo "add remote 'origin'"
	git remote add origin "${url}"
	popd >/dev/null
}

do_view() {
	if [[ ${project} =~ ^[0-9]+$ ]]; then
		# number - assume it is build list id
		w3m "https://${auth}abf.rosalinux.ru/build_lists/${project}"
	else
		# not number - assume it is name of project
		w3m "${projurl}/${project}"
	fi
}

do_publish() {
	local reply=$(wget -qO - https://${auth}abf.rosalinux.ru/api/v1/build_lists/${project}/publish.json)
	if [ -n "${reply}" ]; then
		echo "${reply}" | abb.json.sh | sed -rn 's/^\["message"\][[:space:]]*"(.*)"[[:space:]]*$/'${project}': \1/p'
	else
		echo "${project}: ERROR server returns empty reply. check build id with 'abb status [<project>]'"
	fi
}

do_vars() {
	local varslist="proto server owner branch remote abfyml buildlog restore project rows refresh defaultspec"
	local varslistcase="${varslist[@]// /|}"
	local vars
	if [ ${#args[@]} -eq 0 ]; then
		vars=( $varslist )
	else
		vars=( "${args[@]}" )
	fi
	for i in "${vars[@]}"; do
		case "$i" in
			proto|server|owner|branch|remote|abfyml|buildlog|restore|project|rows|refresh|defaultspec)
				echo "$i=${!i}"
				;;
			auth)
				echo "$i=${!i%@}"
				;;
			*)
				;;
		esac
	done | sort
}

main_case() {
	case "$command" in
		clone|store|status|new|view|build|restore|publish|vars)
			do_${command}
			;;
		*)
			usage "unknown command: $command"
			;;
	esac
}

unset command
declare -a args=()
declare -a opts=()

# parse arguments
for i in "$@"; do
	case "$i" in
		clone|build|store|restore|status|new|view|publish|vars)
			if [ "${command}" == "vars" ]; then
				args=("${args[@]}" "${i%%/}")
			else
				[ -n "${command}" ] && usage "only one command at a time supported, but you want: ${command} and ${i%%/}"
				command=${i%%/}
			fi
			;;
		build?)
			if [ "${command}" == "vars" ]; then
				args=("${args[@]}" "${i%%/}")
			else
				[ -n "${command}" ] && usage "only one command at a time supported, but you want: ${command} and ${i%%/}"
				command="build"
				action="${i/build/-b}"
			fi
			;;
		-b?)
			action="$i"
			;;
		-*)
			opts=("${opts[@]}" "$i")
			;;
		proto=*)
			proto=${i#proto=}
			;;
		server=*)
			server=${i#server=}
			;;
		owner=*)
			owner=${i#owner=}
			;;
		branch=*)
			branch=${i#branch=}
			;;
		remote=*)
			remote=${i#remote=}
			;;
		auth=*)
			auth=${i#auth=}
			;;
		abfyml=*)
			abfyml=${i#abfyml=}
			;;
		buildlog=*)
			buildlog=${i#buildlog=}
			;;
		restore=*)
			restore=${i#restore=}
			;;
		project=*)
			args=("${args[@]}" "${i#project=}")
			;;
		rows=*)
			rows=${i#rows=}
			;;
		refresh=*)
			refresh=${i#refresh=}
			;;
		defaultspec=*)
			defaultspec=${i#defaultspec=}
			;;
		*=*)
			echo "unknown option: ${i}" | sed 's/=.*//'
			exit 1
			;;
		*)
			args=("${args[@]}" "${i%%/}")
			;;
	esac
done

# if auth not empty, add "@" to the end
auth=${auth:+${auth}@}

# check arguments
[ -z "$command" ] && usage "please specify a command"
#[ ${#args[@]} -eq 1 ] && project=${args[0]}

# assume we are not in proj dir
in_proj_dir=0

projurl=${proto}://${auth}${server}/${owner}

case "$command" in
	clone|new)
		[ ${#args[@]} -lt 1 ] && usage "command '${command}' requires at least one argument - project name"
		;;
	build|restore)
		case ${#args[@]} in
			0)
				get_project_from_curdir
				[ -z "${project}" ] && usage "can't determine project name"
				in_proj_dir=1
				;;
			1)
				# silently check if we are in specified project dir
				silent=1 get_project_from_curdir nodir
				if [ -n "${project}" ]; then
					if [ "${project}" == "${args[0]}" ]; then
						in_proj_dir=1
					else
						echo "you specify project '${args[0]}', but it seems that we are in dir of project '${project}'"
						echo -n "so we clone project '${args[0]}'. "
						yesno || exit 1
					fi
				fi
				# if we are out of project dir, clone repo first
				if [ ${in_proj_dir} -eq 0 -a ! -d ${args[0]} ]; then
					restore=none project=${args[0]} do_clone || exit 1
				fi
				;;
			*)
				for project in "${args[@]}"; do
					if [ ! -d "${project}" ]; then
						restore=none do_clone
					fi
				done
				;;
		esac
		;;
	status|view)
		case ${#args[@]} in
			0)
				get_project_from_curdir
				[ -z "${project}" ] && usage "can't determine project name"
				args=(${project})
				;;
			1)
				# silently check if we are in specified project dir
				;;
			*)
				usage "command '${command}' requires zero ore one argument"
				;;
		esac
		;;
	store)
		[ ${#args[@]} -lt 1 ] && usage "command '${command}' requires at least one argument - file name"
		;;
	publish)
		[ ${#args[@]} -lt 1 ] && usage "command '${command}' requires at least one argument - build_list id"
		;;
	vars)
		;;
	*)
		usage "unknown command: $command"
		;;
esac

# need for debug only
print_args() {
	echo "args:"
	for i in "${args[@]}"; do
		echo $i
	done
	echo "opts:"
	for i in "${opts[@]}"; do
		echo $i
	done
	echo "command=$command"
	echo "action=$action"
	echo "url=$url"
}
#print_args; exit

# let's start
if [ ${#args[@]} -eq 0 -o "${command}" == "vars" ]; then
	main_case
else
	for project in "${args[@]}"; do
		in_proj_dir=0
		main_case
	done
fi
