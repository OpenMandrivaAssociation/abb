#!/bin/bash
# vim: sw=2:ts=2:sts=2

# abb is command-line client for abf <http://abf.rosalinux.ru>
# Copyright (C) 2012 alexander barakin aka sash-kan <alex@barak.in>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# defaults:

# using proto (http|https)
proto=https
# server
server=abf.rosalinux.ru
# yes yes!
export GIT_SSL_NO_VERIFY=true
# owner of repo (user name or group name)
owner=import
# default branch
branch=rosa2012.1
# default remote
remote=origin
# insecure:
#auth=user:password
# more secure, but very-very uncomfortable:
#auth=user
# default rpmbuild action
action="-bb"
# name of abf yml file to store sha1sums
abfyml=".abf.yml"
# write buildlog (any, even empty value, cancels log creation)
buildlog=yes

# get user settings
# first look in ~/.abbrc
[ -f ~/.abbrc ] && . ~/.abbrc
# if it does not exist then look for .abbrc in curdir
[ ! -f ~/.abbrc -a -f .abbrc ] && . .abbrc
# if both do not exist, using defaults written above

usage() {
	[ $# == 1 ] && echo -e "$1"
  cat <<EOT
usage:
$0 clone <name of project>
$0 build [<name of project>]
$0 restore [<name of project>]
$0 store <name of file>

settings are in ~/.abbrc
see readme, please!
EOT
	exit 1
}

do_clone() {
	git clone "$url" && [ -d "$project" ] && cd "$project" || exit 2
	if [ -n "$branch" ]; then
		echo "try to checkout to branch '$branch' of remote '$remote'" 
		git checkout -t "$remote/$branch" || exit 2
	fi
}

do_build() {
	echo "try to build"
	#echo ${opts[@]}; exit
	local d=$PWD
	local spec=(*.spec)
	[ ${#spec[@]} -ne 1 ] && { echo "one and only one spec required in current dir"; exit 2; }

	local cmd="rpmbuild --define '_topdir ${d}' --define '_sourcedir ${d}' ${spec}"
	if [ "${buildlog}" == "yes" ]; then
		local logname="${project}.${action}.$(/bin/date +%Y%m%d-%H%M%S.$(printf %05d $$)).$(hostname -s).buildlog"
		eval $cmd $action "${opts[@]}" 2>&1 | tee ${logname}
		echo "build log is saved in ${logname}"
	else
		eval $cmd $action "${opts[@]}"
	fi
}

do_restore() {
	local file sha
	echo "try to restore files from abf storage"
	if [ "${abfyml}" == "" ]; then
		echo "error: name of abf yml file not specified"
		echo "for example:"
		echo "$0 $command abfyml=.abf.yml"
		return 1
	fi
	if [ -e "${abfyml}" ]; then
		echo "parsing file '${abfyml}'"
		sed -rn 's/^\s*"?([^[:space:]:"]+)"?\s*:?\s*"?([0-9a-fA-F]+)"?\s*$/\1 \2/p' ${abfyml} | \
		while read file sha; do
			#echo -n "found entry: file=${file} sha1sum=${sha} ... "
			echo -n "found entry: file=${file} ... "
			if [ -e ${file} ]; then
				if echo "${sha}  ${file}" | sha1sum -c --status; then
					echo "ok"
				else
					echo "sha1sum INCORRECT! skipping..."
				fi
			else
				echo -n "try to download... "
				if wget -q --content-disposition "http://file-store.rosalinux.ru/download/${sha}"; then
					echo "ok"
					echo -n "check sum... "
					if echo "${sha}  ${file}" | sha1sum -c --status; then
						echo "ok"
					else
						echo "sha1sum INCORRECT! skipping..."
					fi
				else
					echo "filed! skipping..."
				fi
			fi
		done
	fi

}

yesno() {
	local cont
	read -p "is it ok? (Y|n): " cont
	[ "${cont}" == "" -o "${cont}" == "y" -o "${cont}" == "Y" ] && return 0
	return 1
}

do_store() {
	local file=${args[0]}
	if [ "${abfyml}" == "" ]; then
		echo "error: name of abf yml file not specified"
		echo "for example:"
		echo "$0 $command $file abfyml=.abf.yml"
		return 1
	fi

	local sha=$(sha1sum "${file}" | sed 's/\s.*//')
	echo "sha1sum = '${sha}'"

	if [ -e "${abfyml}" ]; then
		if grep -qE "\<${file}\>|\<${sha}\>" ${abfyml}; then
			echo "file '${abfyml}' also contains this line:"
			grep -E "\<${file}\>|\<${sha}\>" ${abfyml}
			echo "aborting..."
			return 1
		fi
	fi

	echo -n "check if file also stored... "
	if wget -q --spider http://file-store.rosalinux.ru/download/${sha}; then
		echo "yes"
		echo "skip storing"
	else
		echo "no"
		echo "try to store file ${file}"
		local curloutput=$(curl -s -X POST -F "file_store[file]=@${file}" http://${auth}file-store.rosalinux.ru/api/v1/file_stores)

		echo -n "check if file stored correctly... "
		if wget -q --spider http://file-store.rosalinux.ru/download/${sha}; then
			echo "ok"
		else
			echo "error: can't check"
			echo "curl output:"
			echo ${curloutput}
			echo "aborting..."
			return 1
		fi
	fi
	if [ ! -e "${abfyml}" ]; then
		echo "${abfyml} not exist, create one"
		echo "---" > "${abfyml}"
		echo "sources:" >> "${abfyml}"
	fi
	echo "adding line to '${abfyml}'"
	echo "  ${file}: ${sha}" >> "${abfyml}"
}

unset command
declare -a args=()
declare -a opts=()

# parse arguments
for i in "$@"; do
	case "$i" in
		clone)
			[ -z "$command" ] && command="clone" || args=("${args[@]}" "${i%%/}")
			;;
		build)
			[ -z "$command" ] && command="build" || args=("${args[@]}" "${i%%/}")
			;;
		build?)
			command="build"
			action="${i/build/-b}"
			;;
		store)
			command="store"
			;;
		restore)
			[ -z "$command" ] && command="restore" || args=("${args[@]}" "${i%%/}")
			;;
		-b?)
			action="$i"
			;;
		-*)
			opts=("${opts[@]}" "$i")
			;;
		proto=*)
			proto=${i#proto=}
			;;
		server=*)
			server=${i#server=}
			;;
		owner=*)
			owner=${i#owner=}
			;;
		branch=*)
			branch=${i#branch=}
			;;
		remote=*)
			remote=${i#remote=}
			;;
		auth=*)
			auth=${i#auth=}
			;;
		abfyml=*)
			abfyml=${i#abfyml=}
			;;
		buildlog=*)
			buildlog=${i#buildlog=}
			;;
		*)
			args=("${args[@]}" "${i%%/}")
			;;
	esac
done

# if auth not empty, add "@" to the end
auth=${auth:+${auth}@}

# check arguments
[ -z "$command" ] && usage "please specify a command"
[ ${#args[@]} -eq 1 ] && project=${args[0]}
case "$command" in
	clone)
		[ ${#args[@]} -ne 1 ] && usage "command 'clone' takes one argument - project name"
		;;
	build|restore)
		case ${#args[@]} in
			0)
				# believe that we are in a directory with the source
				project=$(basename $PWD)
				;;
			1)
				[ -d "${args[0]}" -o "$(basename $PWD)" == "${args[0]}" -a -d .git -a -f *.spec ] || { echo "directory '${args[0]}' does not exist, so try to clone first"; \
					do_clone || exit 1; }
				;;
			*)
				usage "command '${command}' needs no arguments - assume we are in dir with sources\nor one argument - dir with sources"
				;;
		esac
		;;
	store)
		[ ${#args[@]} -ne 1 ] && usage "command 'store' takes one argument - file name"
		;;
	*)
		usage "unknown command: $command"
		;;
esac

url=${proto}://${auth}${server}/${owner}/${project}.git

# need for debug only
print_args() {
	echo "args:"
	for i in "${args[@]}"; do
		echo $i
	done
	echo "opts:"
	for i in "${opts[@]}"; do
		echo $i
	done
	echo "command=$command"
	echo "action=$action"
	echo "url=$url"
}
#print_args; exit

# let's start
case "$command" in
	clone)
		do_clone
		;;
	build|restore)
		[ -d "$project" ] && { cd "$project" || exit 1; }
		[ "$(basename $PWD)" == "$project" -a -d .git -a -f *.spec ] || { echo "it seems that this directory does not contain the git repo";  exit 1; }
		do_${command}
		;;
	store)
		do_store
		;;
	*)
		usage "unknown command: $command"
		;;
esac
